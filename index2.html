<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #chordEditor {
            min-height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 18px;
            outline: none;
            white-space: pre-wrap;
            cursor: text;
        }

        .chord {
            font-weight: bold;
            color: #2a9d8f;
            background: rgba(42, 157, 143, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }
        .accidental {
            display: inline-block;
            width: auto;
        }
        .chord-results {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 220px;
            max-height: 40px; /* Ensure minimal space usage */
            overflow: hidden;
            text-align: center;
            white-space: nowrap;
            line-height: 1.2;
            z-index: 10;
            transform: translateY(-120%); /* Move results *above* the line */
            opacity: 0.9;
        }
        .line {
            position: relative; /* Needed for absolute positioning */
            padding-top: 15px; /* Space for floating results */
        }

        #editor-container {
            display: flex;
            gap: 20px;
        }

        #chordEditor {
            flex: 2;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ccc;
            font-size: 18px;
            white-space: pre-wrap;
            outline: none;
            cursor: text;
        }

        #resultsSidebar {
            flex: 1;
            background: #f4f4f4;
            padding: 10px;
            border-left: 2px solid #ddd;
            overflow-y: auto;
            max-height: 300px;
        }
        
    </style>
</head>
<body>

    <h2>Interactive Chord Editor</h2>
    <div id="editor-container">
        <div id="chordEditor" contenteditable="true" spellcheck="false"></div>
        <div id="resultsSidebar"></div>
    </div>

    <script src="lib/lib.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {   
        const editor = document.getElementById("chordEditor");
            // Automatically format chords as the user types
            const observer = new MutationObserver(() => {
                formatChords();
            });

            observer.observe(editor, { childList: true, subtree: true, characterData: true });

            editor.addEventListener("input", () => {
                formatChords(); // Format only newly typed chords
            });

            function updateSidebarResults(text) {
                let sidebar = document.getElementById("resultsSidebar");
                sidebar.innerHTML = ""; // Clear previous results

                let lines = text.split("\n").filter(line => line.trim() !== "");
                lines.forEach((line, index) => {
                    let chords = getChordMatches(line.split(/\s+/));
                    //console.log(chords);
                    if (chords.length > 0) {
                        let resultDiv = document.createElement("div");
                        resultDiv.innerHTML = `<strong>Line ${index + 1}</strong><br>${chords.slice(0, 2).map(chord => `${chord.key} (Score: ${chord.score.toFixed(1)})`).join("<br>")}`;
                        sidebar.appendChild(resultDiv);
                    }
                });
            }

            function formatChords() {
                let selection = window.getSelection();
                let range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

                let textNodes = [...editor.childNodes].filter(node => node.nodeType === 3);
                textNodes.forEach(node => {
                    let formatted = node.textContent.replace(/\b([A-G](?:#|b|♯|♭)?(?:maj7|m7|m|7|dim|sus[24]?)?)\b/g, match => {
                        return `<span class="chord">${match}</span>`;
                    });

                    if (node.textContent !== formatted) {
                        let temp = document.createElement("span");
                        temp.innerHTML = formatted;
                        node.replaceWith(...temp.childNodes);
                    }
                });

                if (range) {
                    selection.removeAllRanges();
                    selection.addRange(range);
                }

                updateSidebarResults(editor.innerText.trim()); // Keep sidebar results updated
            }
        });

        /*document.addEventListener("DOMContentLoaded", function () {
            const editor = document.getElementById("chordEditor");

            function formatChord(chord) {
                const enharmonicMap = {
                    "C#": "Db", "Db": "C#",
                    "D#": "Eb", "Eb": "D#",
                    "F#": "Gb", "Gb": "F#",
                    "G#": "Ab", "Ab": "G#",
                    "A#": "Bb", "Bb": "A#"
                };

                let formattedChord = chord.charAt(0).toUpperCase() + chord.slice(1).toLowerCase();
                formattedChord = formattedChord.replace(/b$/, "♭").replace(/#$/, "♯");

                return enharmonicMap[formattedChord] || formattedChord;
            }

            function updateSidebarResults(text) {
                let sidebar = document.getElementById("resultsSidebar");
                sidebar.innerHTML = ""; // Clear previous results

                let lines = text.split("\n").filter(line => line.trim() !== "");
                lines.forEach((line, index) => {
                    let chords = getChordMatches(line.split(/\s+/));
                    if (chords.length > 0) {
                        let resultDiv = document.createElement("div");
                        resultDiv.innerHTML = `<strong>Line ${index + 1}</strong><br>${chords.slice(0, 2).map(chord => `${chord.key} (Score: ${chord.score.toFixed(1)})`).join("<br>")}`;
                        sidebar.appendChild(resultDiv);
                    }
                });
            }

            // Prevent runaway UI updates
            function showChordResults(lineElement, chords) {
                let resultsContainer = lineElement.querySelector(".chord-results");

                if (!resultsContainer) {
                    resultsContainer = document.createElement("div");
                    resultsContainer.classList.add("chord-results");
                    lineElement.appendChild(resultsContainer);
                }

                // Limit results to top 2 matches
                let topResults = chords.slice(0, 2);

                if (topResults.length === 0) {
                    resultsContainer.style.display = "none";
                    return;
                }

                resultsContainer.innerHTML = topResults
                    .map(chord => `${chord.key} (Score: ${chord.score.toFixed(1)})`)
                    .join("<br>");

                resultsContainer.style.display = "block";
            }
            // Ensure chords stay in one unit
            function formatChord(chord) {
                return chord.replace(/#/g, '♯').replace(/b/g, '♭');
            }

            loadChordData();

            editor.addEventListener("input", highlightChords);
        });*/
    </script>

</body>
</html>